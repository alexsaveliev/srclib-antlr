package com.sourcegraph.toolchain.language;

import com.sourcegraph.toolchain.core.objects.SourceUnit;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.*;

/**
 * Languages registry. Uses service loader mechanism to lookup for installed languages
 */
public class LanguageRegistry {

    private static final Logger LOGGER = LoggerFactory.getLogger(LanguageRegistry.class);

    /**
     * Each source unit generated by current toolchain will contain given prefix, thus making source unit type basic-php,
     * basic-objectivec, basic-brainfuck, ...
     */
    private static final String PREFIX = "basic-";

    private static LanguageRegistry instance;

    /**
     * Map name => language
     */
    private Map<String, Language> map = new HashMap<>();

    /**
     * loads languages support using service loader mechanism
     */
    private LanguageRegistry() {
        ServiceLoader<Language> loader = ServiceLoader.load(Language.class);
        for (Language language : loader) {
            add(language);
        }

    }

    public static LanguageRegistry getInstance() {
        if (instance == null) {
            instance = new LanguageRegistry();
        }
        return instance;
    }

    /**
     * Registers new language
     *
     * @param language language to register
     */
    public void add(Language language) {
        String id = getCanonicalLanguageName(language);
        map.put(id, language);
        LOGGER.info("Added language {}", id);
    }

    /**
     * @param language language name
     * @return return language support associated with given name if there is any
     */
    public Language get(String language) {
        if (!language.startsWith(PREFIX)) {
            return null;
        }
        language = StringUtils.substringAfter(language, PREFIX);
        return map.get(getCanonicalLanguageName(language));
    }

    /**
     * Sequentially asks each registered language support to scan for source units
     *
     * @param rootDir root directory
     * @param repoUri current repository URI
     * @return list of source units found  by all registered language supports
     * @throws IOException
     */
    public Collection<SourceUnit> getSourceUnits(File rootDir, String repoUri) throws IOException {
        Collection<SourceUnit> units = new ArrayList<>();
        for (Language language : map.values()) {
            Collection<SourceUnit> languageUnits = language.getSourceUnits(rootDir, repoUri);
            if (languageUnits == null) {
                continue;
            }
            languageUnits.stream().filter(unit -> !unit.Files.isEmpty()).forEach(unit -> {
                unit.Type = PREFIX + getCanonicalLanguageName(language);
                units.add(unit);
            });
        }
        return units;
    }

    /**
     * @param language language
     * @return canonical language name (lowercase)
     */
    private static String getCanonicalLanguageName(Language language) {
        return getCanonicalLanguageName(language.getName());
    }

    /**
     * @param name language name
     * @return canonical language name (lowercase)
     */
    private static String getCanonicalLanguageName(String name) {
        return name.toLowerCase();
    }
}
